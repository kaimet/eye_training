<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Find the Match</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 10px;
        }
        .canvas-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            max-width: 100vw;
        }
        canvas {
            background-color: white;
            border: 1px solid #000;
            cursor: pointer;
        }
        canvas.reference {
            border: 2px solid blue;
            cursor: default;
        }
        canvas.wrong {
            background-color: #dddddd;
            cursor: not-allowed;
        }
        canvas.correct {
            background-color: #aaffaa;
            cursor: default;
        }
    </style>
</head>
<body>
    <h3>Find the Match</h1>
    <div class="canvas-container" id="canvasContainer"></div>
    <br>
		<a id="mainPageLink" href="index.html">main page</a>




<script> // ===============================

const numCanvases = 6; // Including the reference canvas
let canvasSize = 200;
const numPoints = 8;
const minSegmentLength = 0.25; // in square side length
const maxSegmentLength = 0.7;
const segmentLengthRange = maxSegmentLength - minSegmentLength;
const minAngle = Math.PI * 0.15;
const maxAngle = Math.PI * 0.8;
const turnRange = maxAngle - minAngle;

let referencePoints = [];
let canvases = [];
let correctIndex;


function createCanvases() {
		const container = document.getElementById('canvasContainer');
		container.innerHTML = '';
		canvases = [];
		
		const minSize = Math.min(window.innerWidth - 25, window.innerHeight - 80);
		const maxSize = Math.max(window.innerWidth - 25, window.innerHeight - 80);
		canvasSize = Math.min(minSize / 2 - 15, maxSize / 3 - 30);
		canvasSize = Math.floor(canvasSize);
		container.style.maxWidth = `${(canvasSize + 20) * 3}px`;

		for (let i = 0; i < numCanvases; i++) {
				const canvas = document.createElement('canvas');
				canvas.width = canvas.height = canvasSize;
				canvas.id = `canvas${i}`;
				if (i === 0) {
						canvas.classList.add('reference');
				} else {
						canvas.addEventListener('click', () => checkCanvas(i));
				}
				container.appendChild(canvas);
				canvases.push(canvas);
		}
		
}

function generatePoints(canvas) {
		const points = [];
		let x = canvas.width / 2;
		let y = canvas.height / 2;
		let angle = Math.random() * Math.PI * 2;

		for (let i = 0; i < numPoints; i++) {
				points.push({ x, y });

				let validPoint = false;
				while (!validPoint) {
						const distance = (Math.random() * segmentLengthRange + minSegmentLength) * canvas.width;
						const turnAngle = (Math.random() * turnRange + minAngle) * (Math.random() < 0.5 ? 1 : -1);
						const newAngle = (angle + turnAngle + Math.PI * 2) % (Math.PI * 2);
						const newX = x + Math.cos(newAngle) * distance;
						const newY = y + Math.sin(newAngle) * distance;
						
						const border = 5;
						if (newX >= border && newX < canvas.width - border && newY >= border && newY < canvas.height - border) {
								x = newX;
								y = newY;
								angle = newAngle;
								validPoint = true;
						}
				}
		}

		return points;
}

function drawSpline(ctx, points) {
		ctx.beginPath();
		ctx.moveTo(points[0].x, points[0].y);

		for (let i = 1; i < points.length - 2; i++) {
				const xc = (points[i].x + points[i + 1].x) / 2;
				const yc = (points[i].y + points[i + 1].y) / 2;
				ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
		}

		ctx.quadraticCurveTo(
				points[points.length - 2].x,
				points[points.length - 2].y,
				points[points.length - 1].x,
				points[points.length - 1].y
		);

		ctx.strokeStyle = 'black';
		ctx.lineWidth = 2;
		ctx.stroke();
}

function generateGame() {
		createCanvases();
		referencePoints = generatePoints(canvases[0]);
		drawSpline(canvases[0].getContext('2d'), referencePoints);

		correctIndex = Math.floor(Math.random() * (numCanvases - 1)) + 1;

		for (let i = 1; i < numCanvases; i++) {
				let points;
				if (i === correctIndex) {
						points = [...referencePoints];
				} else {
						points = referencePoints.map(point => ({
								x: point.x + (Math.random() * 0.01 + 0.01) * canvasSize * (Math.random() < 0.5 ? 1 : -1),
								y: point.y + (Math.random() * 0.01 + 0.01) * canvasSize * (Math.random() < 0.5 ? 1 : -1)
						}));
				}
				drawSpline(canvases[i].getContext('2d'), points);
		}
}

function checkCanvas(index) {
		if (index === correctIndex) {
				canvases[index].classList.add('correct');
				canvases[index].removeEventListener('click', () => checkCanvas(index));
				setTimeout(generateGame, 500);
		} else {
				canvases[index].classList.add('wrong');
				canvases[index].removeEventListener('click', () => checkCanvas(index));
		}
}

generateGame();
window.addEventListener('resize', generateGame);


</script>
</body>
</html>