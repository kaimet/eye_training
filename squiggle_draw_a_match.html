<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squiggle Draw</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 0;
            height: 100vh;
						
						user-select: none;
						-webkit-user-select: none;
						-moz-user-select: none;
						-ms-user-select: none;
        }
        .canvas-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 90%;
        }
        canvas {
            background-color: #f0f0f0;
            border: 0px solid #000;
            margin: 10px;
        }
        .button-container {
            display: flex;
            justify-content: center;
            width: 100%;
            padding: 10px 0;
        }
        button {
            font-size: 16px;
            padding: 10px 20px;
            margin: 0 10px;
            cursor: pointer;
        }
        #mainPageLink {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="canvas-container">
        <canvas id="leftCanvas"></canvas>
        <canvas id="rightCanvas"></canvas>
    </div>
    <div class="button-container">
        <button id="generateBtn">New</button>
        <button id="evaluateBtn">Evaluate</button>
    </div>
		<br>
		<a href="squiggle_find_a_match.html">squiggle match</a>
		<br>
    <a id="mainPageLink" href="index.html">home page</a>


<script> // ==============================


const numPoints = 8;
const nFixedBeg = 3;
const nFixedEnd = 2;
const minAngle = Math.PI * 0.15;
const maxAngle = Math.PI * 0.8;
const turnRange = maxAngle - minAngle;
const minSegmentLength = 0.25; // in square side length
const maxSegmentLength = 0.7;
const segmentLengthRange = maxSegmentLength - minSegmentLength;


const leftCanvas = document.getElementById('leftCanvas');
const rightCanvas = document.getElementById('rightCanvas');
const leftCtx = leftCanvas.getContext('2d');
const rightCtx = rightCanvas.getContext('2d');
let scaleFactor = rightCanvas.width / leftCanvas.width;

const generateBtn = document.getElementById('generateBtn');
const evaluateBtn = document.getElementById('evaluateBtn');
//const errorDisplay = document.getElementById('errorDisplay');


const canvasContainer = document.querySelector('.canvas-container');
let isLandscape = window.innerWidth > window.innerHeight;

function resizeCanvases() {
    const containerWidth = canvasContainer.clientWidth;
    const containerHeight = canvasContainer.clientHeight;
    isLandscape = containerWidth > containerHeight;

    let leftSize, rightSize;

    if (isLandscape) {
        let s = Math.floor(Math.min(containerHeight, containerWidth * 0.5));
        leftSize = Math.floor(s * 3/4);
        rightSize = s;
    } else {
        let s = Math.floor(Math.min(containerWidth, containerHeight * 0.5));
        leftSize = Math.floor(s * 3/4);
        rightSize = s;
    }

    const oldLeftSize = leftCanvas.width;
    const oldRightSize = rightCanvas.width;
    leftCanvas.width = leftCanvas.height = leftSize;
    rightCanvas.width = rightCanvas.height = rightSize;

    scaleFactor = rightCanvas.width / leftCanvas.width;

    if (originalPoints.length > 0) {
        scalePoints(originalPoints, oldLeftSize, leftSize);
        drawSpline(leftCtx, originalPoints);
    }
    if (userPoints.length > 0) {
        scalePoints(userPoints, oldRightSize, rightSize);
        drawSpline(rightCtx, userPoints, true);
    }
}

function scalePoints(points, oldSize, newSize) {
    const scaleFactor = newSize / oldSize;
    for (let point of points) {
        point.x = Math.round(point.x * scaleFactor);
        point.y = Math.round(point.y * scaleFactor);
    }
}


let originalPoints = [];
let userPoints = [];
				

function generateRandomPath(canvas) {
    const points = [];
    let x = canvas.width / 2;
    let y = canvas.height / 2;
    let angle = Math.random() * Math.PI * 2;
    const startX = x;
    const startY = y;

    for (let i = 0; i < numPoints; i++) {
        points.push({ x, y });

        let validPoint = false;
        let attempts = 0;
        const maxAttempts = 100;

        while (!validPoint && attempts < maxAttempts) {
            let sl = segmentLengthRange;
            if (i < nFixedBeg || i >= numPoints - nFixedEnd) sl /= 2;
            let ma = minAngle;
            if (i < nFixedBeg || i >= numPoints - nFixedEnd) ma *= 2;
            
            const distance = (Math.random() * sl + minSegmentLength) * canvas.width;
            const turnAngle = (Math.random() * turnRange + ma) * (Math.random() < 0.5 ? 1 : -1);
            const newAngle = (angle + turnAngle + Math.PI * 2) % (Math.PI * 2);
            let newX = x + Math.cos(newAngle) * distance;
            let newY = y + Math.sin(newAngle) * distance;
            
            const border = 0;
            if (newX >= border && newX < canvas.width - border && newY >= border && newY < canvas.height - border) {
                // For the last segment, adjust to close the path
                if (i === numPoints - 1) {
                    const distToStart = Math.sqrt((newX - startX)**2 + (newY - startY)**2);
                    if (distToStart <= distance * 1.5 && distToStart >= distance * 0.5) {
                        newX = startX;
                        newY = startY;
                        validPoint = true;
                    }
                } else {
                    validPoint = true;
                }
            }

            if (validPoint) {
                x = newX;
                y = newY;
                angle = newAngle;
            }

            attempts++;
        }

        if (attempts >= maxAttempts) {
            // If we can't find a valid point, restart the process
            return generateRandomPath(canvas);
        }
    }

    return points;
}

function normalizePath(points, canvas = leftCanvas) {
	let minx = 9999;
	let miny = 9999;
	let maxx = 0;
	let maxy = 0;
	let cx = canvas.width/2 ;
	let cy = canvas.height/2;
	
	//center
	
	points.forEach((p) => {
		minx = Math.min(minx, p.x);
		miny = Math.min(miny, p.y);
		maxx = Math.max(maxx, p.x);
		maxy = Math.max(maxy, p.y);
	}); 
	let offsetX = cx - (minx + maxx)/2;
	let offsetY = cy - (miny + maxy)/2;
	points.forEach((p) => {
		p.x = p.x + offsetX;
		p.y = p.y + offsetY;
	});
	
	//scale
	
	let border = 0;
	let scalef = Math.min((canvas.width-border) / (maxx-minx), 
												(canvas.height-border) / (maxy-miny)) ;
	points.forEach((p) => {
		p.x = cx + (p.x - cx) * scalef;
		p.y = cy + (p.y - cy) * scalef;
	});
	
	return points;
}

// not used
function drawGuides(ctx, points) {
	ctx.beginPath();

	for (let i = nFixedBeg; i < points.length - nFixedEnd; i++) {
			ctx.moveTo(points[i].x, points[i].y);
			let xc = (points[i].x + points[i - 1].x) / 2;
			let yc = (points[i].y + points[i - 1].y) / 2;
			ctx.lineTo(xc, yc);
			
			ctx.moveTo(points[i].x, points[i].y);
			xc = (points[i].x + points[i + 1].x) / 2;
			yc = (points[i].y + points[i + 1].y) / 2;
			ctx.lineTo(xc, yc);
	}

	ctx.strokeStyle = 'gray';
	ctx.lineWidth = 0.5;
	ctx.stroke();
}

function drawPoints(ctx, points) {
	points.forEach((point, index) => {
			if (index >= nFixedBeg && index < points.length - nFixedEnd) {
					/*// original control point
					ctx.beginPath();
					ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
					ctx.strokeStyle = 'gray';
					ctx.lineWidth = 1;
					ctx.stroke();
					*/

					// projected point
					const prevPoint = points[(index - 1 + points.length) % points.length];
					const nextPoint = points[(index + 1) % points.length];
					const midPoint1 = {
							x: (prevPoint.x + point.x) / 2,
							y: (prevPoint.y + point.y) / 2
					};
					const midPoint2 = {
							x: (point.x + nextPoint.x) / 2,
							y: (point.y + nextPoint.y) / 2
					};
					const projectedPoint = findClosestPointOnCurve(midPoint1, point, midPoint2).point;

					ctx.beginPath();
					const r = 6 + rightCanvas.width * 0.01;
					ctx.arc(projectedPoint.x, projectedPoint.y, r, 0, Math.PI * 2);
					ctx.strokeStyle = 'gray';
					ctx.lineWidth = 2;
					ctx.stroke();
			}
	});
}


function drawSpline(ctx, points, showPoints = false, color = 'black', strokeWidth = 3) {
		
		//if (showPoints) drawGuides(ctx, points);
		if (showPoints) drawPoints(ctx, points);
		
		ctx.beginPath();
		
		// Start from the midpoint between the last and first point
    const lastPoint = points[points.length - 1];
    const firstPoint = points[0];
    let midX = (lastPoint.x + firstPoint.x) / 2;
    let midY = (lastPoint.y + firstPoint.y) / 2;
    ctx.moveTo(midX, midY);

    // Draw the first curve
    ctx.quadraticCurveTo(firstPoint.x, firstPoint.y, (firstPoint.x + points[1].x) / 2, (firstPoint.y + points[1].y) / 2);

    // Draw curves for the rest of the points
    for (let i = 1; i < points.length; i++) {
        const p0 = points[i];
        const p1 = points[(i + 1) % points.length]; // Wrap around to the first point
        midX = (p0.x + p1.x) / 2;
        midY = (p0.y + p1.y) / 2;
        ctx.quadraticCurveTo(p0.x, p0.y, midX, midY);
    }
		ctx.closePath();


		ctx.strokeStyle = color;
		ctx.lineWidth = strokeWidth * (ctx == rightCtx ? scaleFactor : 1);
		ctx.stroke();
}

function generateNewLine() {
    leftCtx.clearRect(0, 0, leftCanvas.width, leftCanvas.height);
    rightCtx.clearRect(0, 0, rightCanvas.width, rightCanvas.height);

    originalPoints = normalizePath(generateRandomPath(leftCanvas));
    drawSpline(leftCtx, originalPoints);

    userPoints = originalPoints.map((point, index) => {
        if (index < nFixedBeg || index >= originalPoints.length - nFixedEnd) {
            return { x: point.x * scaleFactor, y: point.y * scaleFactor };
        } else {
            let x = 0; 
            let y = 0;
            do {
                const displacement = (Math.random() * 0.025 + 0.05) * rightCanvas.width;
                const angle = Math.random() * Math.PI * 2;
                x = point.x * scaleFactor + Math.cos(angle) * displacement;
                y = point.y * scaleFactor + Math.sin(angle) * displacement;
            } while (x < 0 || y < 0 || x > rightCanvas.width || y > rightCanvas.height);
            
            return {x: x, y: y};
        }
    });

    drawSpline(rightCtx, userPoints, true);
}

function evaluateDrawing() {
		/*let totalError = 0;
		for (let i = 3; i < numPoints; i++) {
				const dx = userPoints[i].x / scaleFactor - originalPoints[i].x;
				const dy = userPoints[i].y / scaleFactor - originalPoints[i].y;
				totalError += Math.sqrt(dx * dx + dy * dy);
		}
		//errorDisplay.textContent = `Total Error: ${totalError.toFixed(0)} pixels`;
		*/
		
		drawSpline(leftCtx, originalPoints);
		drawSpline(rightCtx, originalPoints.map(p => ({ x: p.x * scaleFactor, y: p.y * scaleFactor })), false, 'blue');
}

generateBtn.addEventListener('click', generateNewLine);
evaluateBtn.addEventListener('click', evaluateDrawing);


// Project a control point onto the curve
function projectPointOnCurve(p0, p1, p2, t) {
    const x = (1-t)*(1-t)*p0.x + 2*(1-t)*t*p1.x + t*t*p2.x;
    const y = (1-t)*(1-t)*p0.y + 2*(1-t)*t*p1.y + t*t*p2.y;
    return {x, y};
}

// Find the closest point on the curve to the control point
function findClosestPointOnCurve(p0, p1, p2) {
    let minDist = Infinity;
    let bestT = 0;
    let bestPoint = null;

    for (let t = 0; t <= 1; t += 0.01) {
        const point = projectPointOnCurve(p0, p1, p2, t);
        const dist = Math.sqrt((point.x - p1.x)**2 + (point.y - p1.y)**2);
        if (dist < minDist) {
            minDist = dist;
            bestT = t;
            bestPoint = point;
        }
    }

    return {point: bestPoint, t: bestT};
}

// not used
// Lift a point from the curve to its corresponding control point
function liftPointFromCurve(p0, p2, curvePoint) {
    // Solve the quadratic Bézier equation for the control point
    const t = findClosestPointOnCurve(p0, curvePoint, p2).t;
    if (t === 0 || t === 1) return curvePoint; // Edge case

    const x = (curvePoint.x - (1-t)*(1-t)*p0.x - t*t*p2.x) / (2*(1-t)*t);
    const y = (curvePoint.y - (1-t)*(1-t)*p0.y - t*t*p2.y) / (2*(1-t)*t);

    return {x, y};
}


let draggingPoint = null;
let dragOffsetX = 0;
let dragOffsetY = 0;

rightCanvas.addEventListener('mousedown', startDragging);
rightCanvas.addEventListener('mousemove', drag);
rightCanvas.addEventListener('mouseup', stopDragging);
rightCanvas.addEventListener('touchstart', handleTouch);
rightCanvas.addEventListener('touchmove', handleTouch);
rightCanvas.addEventListener('touchend', stopDragging);

function startDragging(e) {
    const rect = rightCanvas.getBoundingClientRect();
    const x = (e.clientX || e.touches[0].clientX) - rect.left;
    const y = (e.clientY || e.touches[0].clientY) - rect.top;
    
    let minD = Infinity;
    for (let i = nFixedBeg; i < userPoints.length - nFixedEnd; i++) {
        const point = userPoints[i];
        let d = (x - point.x) ** 2 + (y - point.y) ** 2;
				if (d < minD) {
						minD = d;
						draggingPoint = i;
						dragOffsetX = point.x - x;
						dragOffsetY = point.y - y;
				}
    }
}

function drag(e) {
    if (draggingPoint !== null) {
        const rect = rightCanvas.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        
        userPoints[draggingPoint].x = x + dragOffsetX;
        userPoints[draggingPoint].y = y + dragOffsetY;

        rightCtx.clearRect(0, 0, rightCanvas.width, rightCanvas.height);
        drawSpline(rightCtx, userPoints, true);
    }
}

function stopDragging() {
    draggingPoint = null;
    dragOffsetX = 0;
    dragOffsetY = 0;
}

function handleTouch(e) {
    e.preventDefault();
    if (e.type === 'touchstart') {
        startDragging(e);
    } else if (e.type === 'touchmove') {
        drag(e);
    }
}



resizeCanvases();
//window.addEventListener('load', resizeCanvases);
window.addEventListener('resize', resizeCanvases);
window.addEventListener('orientationchange', resizeCanvases);

generateNewLine();

</script>
</body>
</html>