<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squigle Match</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 0;
            height: 100vh;
        }
        .canvas-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 90%;
        }
        canvas {
            background-color: white;
            border: 1px solid #000;
            margin: 10px;
        }
        .button-container {
            display: flex;
            justify-content: center;
            width: 100%;
            padding: 10px 0;
        }
        button {
            font-size: 16px;
            padding: 10px 20px;
            margin: 0 10px;
            cursor: pointer;
        }
        #mainPageLink {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="canvas-container">
        <canvas id="leftCanvas"></canvas>
        <canvas id="rightCanvas"></canvas>
    </div>
    <div class="button-container">
        <button id="generateBtn">New</button>
        <button id="evaluateBtn">Evaluate</button>
    </div>
    <a id="mainPageLink" href="index.html">main page</a>


<script> // ==============================


const numPoints = 8;
const minAngle = Math.PI * 0.15;
const maxAngle = Math.PI * 0.8;
const turnRange = maxAngle - minAngle;
const minSegmentLength = 40;
const maxSegmentLength = 100;
const segmentLengthRange = maxSegmentLength - minSegmentLength;


const leftCanvas = document.getElementById('leftCanvas');
const rightCanvas = document.getElementById('rightCanvas');
const leftCtx = leftCanvas.getContext('2d');
const rightCtx = rightCanvas.getContext('2d');
let scaleFactor = rightCanvas.width / leftCanvas.width;

const generateBtn = document.getElementById('generateBtn');
const evaluateBtn = document.getElementById('evaluateBtn');
//const errorDisplay = document.getElementById('errorDisplay');


const canvasContainer = document.querySelector('.canvas-container');
let isLandscape = window.innerWidth > window.innerHeight;

function resizeCanvases() {
    const containerWidth = canvasContainer.clientWidth;
    const containerHeight = canvasContainer.clientHeight;
    isLandscape = containerWidth > containerHeight;

    let leftSize, rightSize;

    if (isLandscape) {
        let s = Math.min(containerHeight, containerWidth * 0.5);
				leftSize = s * 3/4;
        rightSize = s;
    } else {
        let s = Math.min(containerWidth, containerHeight * 0.5);
				leftSize = s * 3/4;
        rightSize = s;
    }

    leftCanvas.width = leftCanvas.height = leftSize;
    rightCanvas.width = rightCanvas.height = rightSize;

    scaleFactor = rightCanvas.width / leftCanvas.width;

    // Redraw canvases
    if (originalPoints.length > 0) {
        drawSpline(leftCtx, originalPoints);
    }
    if (userPoints.length > 0) {
        drawSpline(rightCtx, userPoints, true);
    }
}


let originalPoints = [];
let userPoints = [];
				

function generateRandomPath(canvas) {
    const points = [];
    let x = canvas.width / 2;
    let y = canvas.height / 2;
    let angle = Math.random() * Math.PI * 2;

    for (let i = 0; i < numPoints; i++) {
        points.push({ x, y });

        let validPoint = false;
        while (!validPoint) {
            const distance = Math.random() * segmentLengthRange + minSegmentLength;
            const turnAngle = (Math.random() * turnRange + minAngle) * (Math.random() < 0.5 ? 1 : -1);
            const newAngle = (angle + turnAngle + Math.PI * 2) % (Math.PI * 2);
            const newX = x + Math.cos(newAngle) * distance;
            const newY = y + Math.sin(newAngle) * distance;
            
            const border = 5;
            if (newX >= border && newX < canvas.width - border && newY >= border && newY < canvas.height - border) {
                x = newX;
                y = newY;
                angle = newAngle;
                validPoint = true;
            }
        }
    }

    return points;
}

function drawSpline(ctx, points, showPoints = false, color = 'black', strokeWidth = 3) {
		ctx.beginPath();
		ctx.moveTo(points[0].x, points[0].y);

		for (let i = 1; i < points.length - 2; i++) {
				const xc = (points[i].x + points[i + 1].x) / 2;
				const yc = (points[i].y + points[i + 1].y) / 2;
				ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
		}

		ctx.quadraticCurveTo(
				points[points.length - 2].x,
				points[points.length - 2].y,
				points[points.length - 1].x,
				points[points.length - 1].y
		);

		ctx.strokeStyle = color;
		ctx.lineWidth = strokeWidth * (ctx == rightCtx ? scaleFactor : 1);
		ctx.stroke();

		if (showPoints) {
				points.forEach((point, index) => {
						if (index > 2) {
							ctx.beginPath();
							ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
							ctx.fillStyle = index < 3 ? 'gray' : 'red';
							//ctx.fill();
							ctx.strokeStyle = 'gray';
							ctx.lineWidth = 1;
							ctx.stroke();
						}
				});
		}
}

function generateNewLine() {
    leftCtx.clearRect(0, 0, leftCanvas.width, leftCanvas.height);
    rightCtx.clearRect(0, 0, rightCanvas.width, rightCanvas.height);

    originalPoints = generateRandomPath(leftCanvas);
    drawSpline(leftCtx, originalPoints);

    userPoints = originalPoints.map((point, index) => {
        if (index < 3) {
            return { x: point.x * scaleFactor, y: point.y * scaleFactor };
        } else {
            let x = 0; 
            let y = 0;
            do {
                const displacement = Math.random() * 30 + 20;
                const angle = Math.random() * Math.PI * 2;
                x = point.x * scaleFactor + Math.cos(angle) * displacement;
                y = point.y * scaleFactor + Math.sin(angle) * displacement;
            } while (x < 0 || y < 0 || x > rightCanvas.width || y > rightCanvas.height);
            
            return {x: x, y: y};
        }
    });

    drawSpline(rightCtx, userPoints, true);
}

function evaluateDrawing() {
		let totalError = 0;
		for (let i = 3; i < numPoints; i++) {
				const dx = userPoints[i].x / scaleFactor - originalPoints[i].x;
				const dy = userPoints[i].y / scaleFactor - originalPoints[i].y;
				totalError += Math.sqrt(dx * dx + dy * dy);
		}
		//errorDisplay.textContent = `Total Error: ${totalError.toFixed(0)} pixels`;
		
		drawSpline(leftCtx, originalPoints);
		drawSpline(rightCtx, originalPoints.map(p => ({ x: p.x * scaleFactor, y: p.y * scaleFactor })), false, 'blue');
}

generateBtn.addEventListener('click', generateNewLine);
evaluateBtn.addEventListener('click', evaluateDrawing);



let draggingPoint = null;

rightCanvas.addEventListener('mousedown', startDragging);
rightCanvas.addEventListener('mousemove', drag);
rightCanvas.addEventListener('mouseup', stopDragging);
rightCanvas.addEventListener('touchstart', handleTouch);
rightCanvas.addEventListener('touchmove', handleTouch);
rightCanvas.addEventListener('touchend', stopDragging);

function startDragging(e) {
    const rect = rightCanvas.getBoundingClientRect();
    const x = (e.clientX || e.touches[0].clientX) - rect.left;
    const y = (e.clientY || e.touches[0].clientY) - rect.top;
		
		let minD = 9999;
    for (let i = 3; i < userPoints.length; i++) {
        const point = userPoints[i];
        let d = (x - point.x) ** 2 + (y - point.y) ** 2;
				if (d < 2500) {
            if (d < minD) {
							draggingPoint = i;
							minD = d;
						}
        }
    }
}

function drag(e) {
    if (draggingPoint !== null) {
        const rect = rightCanvas.getBoundingClientRect();
        userPoints[draggingPoint].x = (e.clientX || e.touches[0].clientX) - rect.left;
        userPoints[draggingPoint].y = (e.clientY || e.touches[0].clientY) - rect.top;

        rightCtx.clearRect(0, 0, rightCanvas.width, rightCanvas.height);
        drawSpline(rightCtx, userPoints, true);
    }
}

function stopDragging() {
    draggingPoint = null;
}

function handleTouch(e) {
    e.preventDefault();
    if (e.type === 'touchstart') {
        startDragging(e);
    } else if (e.type === 'touchmove') {
        drag(e);
    }
}



resizeCanvases();
window.addEventListener('resize', resizeCanvases);
window.addEventListener('orientationchange', resizeCanvases);

generateNewLine();

</script>
</body>
</html>